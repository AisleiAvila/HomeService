import { Injectable, signal, inject } from "@angular/core";
import { SupabaseService } from "./supabase.service";
import { NotificationService } from "./notification.service";
import { AuthService } from "./auth.service";
import { I18nService } from "./i18n.service";
import {
  User,
  ServiceRequest,
  ChatMessage,
  ServiceCategory,
  ServiceStatus,
  PaymentStatus,
  ServiceRequestPayload,
} from "../models/maintenance.models";

@Injectable({
  providedIn: "root",
})
export class DataService {
  private supabase = inject(SupabaseService);
  private notificationService = inject(NotificationService);
  private authService = inject(AuthService);
  private i18n = inject(I18nService);

  // Signals for storing application data
  readonly users = signal<User[]>([]);
  readonly serviceRequests = signal<ServiceRequest[]>([]);
  readonly chatMessages = signal<ChatMessage[]>([]);
  // Service categories - will be loaded from Supabase
  readonly categories = signal<ServiceCategory[]>([]);

  constructor() {
    this.listenToServiceRequestChanges();
    this.listenToUserChanges();
    // Add sample data for pagination testing
    this.addSampleDataForTesting();
  }

  private addSampleDataForTesting() {
    console.log('ðŸ”§ Adding sample data for testing...');
    
    // Add sample users
    const sampleUsers: User[] = [
      {
        id: 1,
        auth_id: "test-client-1",
        name: "JoÃ£o Silva",
        email: "joao@example.com",
        role: "client",
        status: "Active",
        phone: "11999999999",
        avatar_url: null,
        specialties: [],
        address: {
          street: "Rua A, 123",
          city: "SÃ£o Paulo",
          state: "SP",
          zip_code: "01234-567",
        },
      },
      {
        id: 2,
        auth_id: "test-professional-1",
        name: "Maria Santos",
        email: "maria@example.com",
        role: "professional",
        status: "Active",
        phone: "11888888888",
        avatar_url: null,
        specialties: ["Plumbing", "Electrical"],
        address: {
          street: "Rua B, 456",
          city: "SÃ£o Paulo",
          state: "SP",
          zip_code: "01234-568",
        },
      },
      {
        id: 3,
        auth_id: "test-admin-1",
        name: "Admin Sistema",
        email: "admin@example.com",
        role: "admin",
        status: "Active",
        phone: "11777777777",
        avatar_url: null,
        specialties: [],
        address: {
          street: "Rua C, 789",
          city: "SÃ£o Paulo",
          state: "SP",
          zip_code: "01234-569",
        },
      },
    ];

    // Add sample service requests
    const sampleRequests: ServiceRequest[] = [];
    for (let i = 1; i <= 25; i++) {
      sampleRequests.push({
        id: i,
        client_id: 1,
        professional_id: i % 3 === 0 ? 2 : null,
        client_auth_id: "test-client-1",
        professional_auth_id: i % 3 === 0 ? "test-professional-1" : null,
        title: `ServiÃ§o de teste ${i}`,
        description: `DescriÃ§Ã£o detalhada do serviÃ§o ${i}`,
        category: [
          "Plumbing",
          "Electrical",
          "Cleaning",
          "Gardening",
          "Painting",
        ][i % 5] as ServiceCategory,
        street: `Rua Teste ${i}, ${100 + i}`,
        city: "SÃ£o Paulo",
        state: "SP",
        zip_code: `0${String(i).padStart(4, "0")}-000`,
        status: ["Pending", "Quoted", "Approved", "In Progress", "Completed"][
          i % 5
        ] as ServiceStatus,
        payment_status: i % 3 === 0 ? "Paid" : ("Unpaid" as PaymentStatus),
        requested_date: new Date(
          Date.now() - i * 24 * 60 * 60 * 1000
        ).toISOString(),
        scheduled_date:
          i % 4 === 0
            ? new Date(Date.now() + i * 24 * 60 * 60 * 1000).toISOString()
            : null,
        cost: i % 2 === 0 ? 100 + i * 10 : null,
        client_name: "JoÃ£o Silva",
        professional_name: i % 3 === 0 ? "Maria Santos" : "NÃ£o atribuÃ­do",
      });
    }

    this.users.set(sampleUsers);
    this.serviceRequests.set(sampleRequests);
    this.categories.set([
      "Plumbing",
      "Electrical",
      "Cleaning",
      "Gardening",
      "Painting",
    ]);
    
    console.log(`âœ… Sample data loaded: ${sampleUsers.length} users, ${sampleRequests.length} requests`);
  }

  async loadInitialData(currentUser: User) {
    await this.fetchUsers();
    await this.fetchServiceRequests(currentUser);
    await this.fetchCategories();
  }

  clearData() {
    this.users.set([]);
    this.serviceRequests.set([]);
    this.chatMessages.set([]);
    this.categories.set([]);
  }

  private async fetchUsers() {
    const { data, error } = await this.supabase.client
      .from("users")
      .select("*");
    if (error) {
      console.log("Error fetching users from Supabase, keeping sample data:", error.message);
      this.notificationService.addNotification(
        "Using sample data - Error fetching users: " + error.message
      );
    } else if (data && data.length > 0) {
      console.log("Loaded users from Supabase:", data.length);
      this.users.set(data as User[]);
    } else {
      console.log("No users found in Supabase, keeping sample data");
    }
  }

  private async fetchServiceRequests(currentUser: User) {
    let query = this.supabase.client.from("service_requests").select("*");

    if (currentUser.role === "client") {
      query = query.eq("client_auth_id", currentUser.auth_id);
    } else if (currentUser.role === "professional") {
      query = query.or(
        `professional_auth_id.eq.${currentUser.auth_id},professional_id.is.null`
      );
    }
    // Admin sees all

    const { data, error } = await query;

    if (error) {
      console.log("Error fetching service requests from Supabase, keeping sample data:", error.message);
      this.notificationService.addNotification(
        "Using sample data - Error fetching service requests: " + error.message
      );
    } else if (data && data.length > 0) {
      console.log("Loaded service requests from Supabase:", data.length);
      const users = this.users();
      const requests = (data as any[]).map((r) => ({
        ...r,
        client_name: users.find((u) => u.id === r.client_id)?.name || "Unknown",
        professional_name:
          users.find((u) => u.id === r.professional_id)?.name || "Unassigned",
      }));
      this.serviceRequests.set(requests);
    } else {
      console.log("No service requests found in Supabase, keeping sample data");
    }
  }

  private async fetchCategories() {
    const { data, error } = await this.supabase.client
      .from("service_categories")
      .select("*")
      .order("name");

    if (error) {
      console.log("Error fetching categories from Supabase, keeping sample data:", error.message);
      this.notificationService.addNotification(
        "Using sample data - Error fetching categories: " + error.message
      );
      // Keep default categories if fetch fails
    } else if (data && data.length > 0) {
      console.log("Loaded categories from Supabase:", data.length);
      // Assuming the table has a 'name' column
      this.categories.set(data.map((cat: any) => cat.name));
    } else {
      console.log("No categories found in Supabase, keeping sample data");
    }
  }

  async addServiceRequest(payload: ServiceRequestPayload) {
    const currentUser = this.authService.appUser();
    if (!currentUser) {
      throw new Error("User not authenticated");
    }

    const newRequestData = {
      client_id: currentUser.id,
      client_auth_id: currentUser.auth_id,
      title: payload.title,
      description: payload.description,
      category: payload.category,
      street: payload.address.street,
      city: payload.address.city,
      state: payload.address.state,
      zip_code: payload.address.zip_code,
      requested_date: new Date().toISOString(),
      status: "Pending",
      payment_status: "Unpaid",
    };

    const { error } = await this.supabase.client
      .from("service_requests")
      .insert(newRequestData);

    if (error) {
      this.notificationService.addNotification(
        "Error creating service request: " + error.message
      );
      throw error;
    } else {
      this.notificationService.addNotification(
        "Service request created successfully!"
      );
      // Reload service requests to show the new one
      const currentUser = this.authService.appUser();
      if (currentUser) {
        await this.fetchServiceRequests(currentUser);
      }
      return true;
    }
  }

  async updateServiceRequest(id: number, updates: Partial<ServiceRequest>) {
    // Get current request to track status changes
    const currentRequest = this.getServiceRequestById(id);

    const { error } = await this.supabase.client
      .from("service_requests")
      .update(updates)
      .eq("id", id);

    if (error) {
      this.notificationService.addNotification(
        "Error updating request: " + error.message
      );
    } else {
      // Notify about status changes
      if (
        updates.status &&
        currentRequest &&
        currentRequest.status !== updates.status
      ) {
        this.notificationService.addNotification(
          this.i18n.translate("statusChangedFromTo", {
            id: id.toString(),
            from: currentRequest.status,
            to: updates.status,
          })
        );
      }

      // Notify about payment status changes
      if (
        updates.payment_status &&
        currentRequest &&
        currentRequest.payment_status !== updates.payment_status
      ) {
        this.notificationService.addNotification(
          this.i18n.translate("paymentStatusChanged", {
            id: id.toString(),
            status: updates.payment_status,
          })
        );
      }
    }
  }

  getServiceRequestById(id: number): ServiceRequest | undefined {
    return this.serviceRequests().find((r) => r.id === id);
  }

  respondToQuote(requestId: number, approved: boolean) {
    const status: ServiceStatus = approved ? "Approved" : "Pending";
    this.updateServiceRequest(requestId, { status });
    this.notificationService.addNotification(
      `Quote for request #${requestId} has been ${
        approved ? "approved" : "rejected"
      }.`
    );
  }

  async scheduleServiceRequest(
    requestId: number,
    professionalId: number,
    scheduledDate: Date
  ) {
    const updates = {
      professional_id: professionalId,
      scheduled_date: scheduledDate.toISOString(),
      status: "Scheduled" as ServiceStatus,
    };

    await this.updateServiceRequest(requestId, updates);
    this.notificationService.addNotification(
      `Service request #${requestId} has been scheduled.`
    );
  }

  async updatePaymentStatus(requestId: number, paymentStatus: PaymentStatus) {
    await this.updateServiceRequest(requestId, {
      payment_status: paymentStatus,
    });
    this.notificationService.addNotification(
      this.i18n.translate("paymentStatusChanged", {
        id: requestId.toString(),
        status: paymentStatus,
      })
    );
  }

  async updateUser(userId: number, updates: Partial<User>) {
    const { error } = await this.supabase.client
      .from("users")
      .update(updates)
      .eq("id", userId);

    if (error) {
      this.notificationService.addNotification(
        "Error updating user: " + error.message
      );
    } else {
      // Refresh users data
      await this.fetchUsers();

      // Notify about user updates
      if (updates.status) {
        this.notificationService.addNotification(
          this.i18n.translate("userStatusUpdated", {
            id: userId.toString(),
            status: updates.status,
          })
        );
      }
    }
  }

  getProfessionalsByCategory(category: ServiceCategory): User[] {
    return this.users().filter(
      (user) =>
        user.role === "professional" &&
        user.status === "Active" &&
        (user.specialties?.includes(category) || !user.specialties?.length)
    );
  }

  async fetchChatMessages(requestId: number) {
    const { data, error } = await this.supabase.client
      .from("chat_messages")
      .select("*")
      .eq("request_id", requestId)
      .order("timestamp", { ascending: true });

    if (error) {
      this.notificationService.addNotification(
        "Error fetching messages: " + error.message
      );
    } else {
      this.chatMessages.set(data as ChatMessage[]);
    }
  }

  async addChatMessage(requestId: number, senderId: number, text: string) {
    const currentUser = this.authService.appUser();
    if (!currentUser) return;

    const newMessage = {
      request_id: requestId,
      sender_id: senderId,
      sender_auth_id: currentUser.auth_id,
      text: text,
      timestamp: new Date().toISOString(),
    };

    const { error } = await this.supabase.client
      .from("chat_messages")
      .insert(newMessage);

    if (error) {
      this.notificationService.addNotification(
        "Error sending message: " + error.message
      );
    }
  }

  private listenToServiceRequestChanges() {
    this.supabase.client
      .channel("public:service_requests")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "service_requests" },
        () => {
          const user = this.authService.appUser();
          if (user) {
            this.fetchServiceRequests(user);
          }
        }
      )
      .subscribe();
  }

  private listenToUserChanges() {
    this.supabase.client
      .channel("public:users")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "users" },
        () => {
          this.fetchUsers();
        }
      )
      .subscribe();
  }
}
